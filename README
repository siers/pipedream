Pipemaze.hs   this is the solver
notes         scratchpad
samples/      here are the samples
problems/     tiny files for ironing out problems

http://raitis.veinbahs.lv/maze/doc/Pipemaze.html

running
  nix-shell shell.nix --run 'ghc Main.hs -o solve && ./solve samples/2'

running with websocket
  nix-shell shell.nix --run 'ghc Main.hs -o solve && time bench=True websocket=maze-server/pipes/#1,2,3,4,5,6 ./solve'

generate docs
  haddock Pipemaze.hs -o haddock -h --hyperlinked-source --quickjump

fun things to do for visualizations:
  remove coloring by equivalent parts in renderWithPositions
  screw with the score variable in sortContinues (this will likely lead to bad solve times)
  increase the frequency to see more intermediate steps

--

with profiler
  % ghc -prof -fprof-auto -rtsopts solve -with-rtsopts='-p' -fexternal-interpreter && ./solve < samples/1

print trace of crash
  % ghc Main.hs -o solve -prof -with-rtsopts='-xc' && ./solve < samples/2

restrict heap
  $ ghc Main.hs -o solve -rtsopts -with-rtsopts='-M1024m' && ./solve < samples/3

run 8 cores
  % ghc Main.hs -o solve -threaded -with-rtsopts='-N8' && time ./solve < ./samples/3

:l solve without having to resolve all type errors (amazing!)
  % ghci -fdefer-type-errors

--

with trace=4 you can make images in images/

after creating images you can animate them by running ./images/animate without any arguments (uses last directory)

insert this after "initSolve" to generate all solutions (works for 1..5 levels)
  flip (iterateMaybeM 1000) (p, 0) $ \(p, n) -> do
    p <- solve' p
    traverse ((liftIO . putStrLn =<<) . liftIO . renderStr . (\Progress{maze} -> maze)) p
    fmap (, n + 1) <$> traverse (renderImage' ("solution-" ++ show n)) p
  error "die"
  -- AND comment out the following line:
  solve' p@Progress{depth, maze=MMaze{size}} | depth == size = pure (Just p) -- remove this to compute all solutions

--

get more samples
  % (set -x; for i in {1..50}; do suffix=-$i ./samples/get 4 &; done; wait < <(jobs -p))

get 50 samples per level
  % (set -x; for level in {1..6}; do for i in {01..50}; do format="trash/samples/%i-$i" ./samples/get $level &; done; done; wait < <(jobs -p))

--

┏╸╺┓┏━╸╻┏━━╸╺┳╸╻╻╻╻╺┳╸┏━┓
┗┳┳┻┻╸╻┣╋╸╻╻╺┫┏┫┃┣┫╻┗┳┻┓╹
┏┛┗━━┓┗┫╹╺┫┗┳┛╹┣┛╹┗╋╸┃╻┗╸
┣━┳━╸┗┳╋━┓┣━╋╸╺╋╸╺┓┗┓┃┃┏┓
╹┏┻┓┏┓┃┣┓┃┃╺┫╺┳┫╺┓┃┏┻┫┣┛╹
╻┣╸╹╹┗┫┃╹┃┗╸┣━┛╹╻┣┫┃╺┻╋┓╻
┗┻╸╻┏┓╹╹╻┗┓╺┻┳━╸╹┣╋┻┓╻╹╹┃
╺┓┏┛┃┣┓╻┗┳┻┓┏┛╻┏━┫┗╸┗┛┏━┛
╻┗┫╺┛╹┗┻━┫╺┫┣━┻┻┓┗╸╺┓╺╋━╸
┃╻┣━━━┓╺━┫╻┗┛┏┳╸┣╸┏━┫┏╋┓╻
┃┃┃╺┓╻┃┏┳┛┗┳━┛┃╺┫╺┫╻┗┛╹┗┫
┣┻┛╺╋┻┛╹┃╺┓┣━╸╹╺╋━╋┻╸╻╻┏┫
╹┏┳━╋┳╸┏┻┓┣┛╺┳┓┏╋╸╹┏┳╋┻┫╹
╻┃┗╸┃┗┳┛╺╋┛╻╻╹┃┃╹╺┓╹┃┣╸┗╸
┣╋━╸╹┏╋━╸┗━┛┣╸┣┻━┳┫╻╹┃╻┏╸
┃┣╸╻╻╹┃╻╺━┓┏┛╺┻┳╸╹┃┣╸┃┃┣╸
╹╹╻┗╋━┻┛╺┳┛┗━┓╻┗╸╺┻┻┓┃┃┣┓
╻╻┣┳┻┳━╸┏┻━┳┓┣┻━━┳━┳┛┣┻┛┃
┣┻┫┃╻┗┳╸┣┓╺┫┣╋╸╺━┛┏┛╻┃╻╺┫
╹╺┛╹┗━┛╺┛╹╺┛╹┗━━╸╺┻╸┗┻┻╸╹
