ws ws://maze.server.host/game-pipes/

┓┻┣┣┫┛╹┏
╹┃╺┃╺╸╹┻
╻┛╹━╺╻┓┃
┗━━┻┏┳┣┓
┗━┃┣┃┻╻╺
━╻┛┳┃┳╺━
┃┳┫┳╺┣┛━
┗┓╸╻╺┛┛┏

["━", "┛", "┃", "┫", "┗", "┓", "┻", "╹", "┣", "╺", "┏", "╻", "╸", "┳", "╋"]

━
┃
┏
┓
┗
┛
┣
┫
┳
┻
╋
╸
╹
╺
╻

1,    ╹
12,   ┗
123,  ┣
1234, ╋
124,  ┻
13,   ┃
134,  ┫
14,   ┛
2,    ╺
23,   ┏
234,  ┳
24,   ━
3,    ╻
34,   ┓
4,    ╸

1: 8x8
5: 1200x130
6: 3000x1000

    validateDirection d =
      trace (show (d, rot, "//", filter (flipDir d ==) thisRequires, filter (flipDir d ==) thatRequires)) $
      filter (flipDir d ==) thisRequires == filter (flipDir d ==) thatRequires

            killStrandedSides :: [()]
            killStrandedSides =
              if any stranded $ cursorDeltasSafe maze cur unpointed
              then []
              else [()]
              where
                unpointed = flipPix $ mapChar rotated
                stranded = cursorDeltasSafe maze

--

I: ━, ┃
L: ┏, ┛, ┓, ┗
T: ┣, ┫, ┳, ┻
X: ╋
i: ╸, ╹, ╺, ╻

1. mums nevajag immutable, mums vajag mutable
1.1. mutable ja tikai viens

2. mums vajag a*?
2.1. store order in btree (has min/max keys?)

3. jāsāk ar malām. vai mums vajag checkerboardā likt klucīšus lai būtu labāki minējumi immediately?

4. iespējams, ka var optimizēt sākot rēķināt no singletoniem

5. varbūt, ka lētāk ir storēt directionus vai nu vektorā vai optimizēt ar lookup table
5.2. special character for wall/uncertain
5.3. optimizēt best ar hashmap O(1), kas ir valīds visiem boardiem

6. simetrijām var nečekot rotācijas (krustam/taisnēm)

7. strongly connected
7.1. ja šis ir solved un ir T vai I, tad var solvēt dažus no apkārtējiem zariem (ja nekonnektējas) – they're forced
7.2. ja šis apmeklēts, tad solved set
7.3. ja rotation is pixValid, tad continue list = (new branches + forced + continue) filter solved. start with first from continue
7.4. ja continue ir empty & size == boardsize, tad valid

8. rotations = filter pixvalid rotations
8.1. if rotations == 1, tad var lietot mutable implement uz boarda

--

2020-12-26-18:55:23
✔ 1. Sides first in backtracking
2. Solve edge first, sort by solvability
✔ 3. Force unpointed
✔. Check stranded islands (jo dziļāk, jo dziļāk vērts rekursēt)
✔. Store origin in cursors
✔. Render cursor with list of sets per color
7. Subsolve regions around edges that don't touch each other, then combine partially solved solutions
7.1. index partial sets by origin cursor

--

9f9a4fe
runhaskell solve.hs 2>&1 < samples/2  15.52s user 2.79s system 59% cpu 30.526 total

9f9a4fe + usePixValidPrecomputed
runhaskell solve.hs 2>&1 < samples/2  74.92s user 3.69s system 84% cpu 1:33.56 total
(actual solving timed with phone: 30s... same as with usePixValidPrecomputed = False)

./solve < samples/2-2  4.36s user 0.02s system 99% cpu 4.380 total

--

% samples/get 1; runhaskell solve.hs 2>&1 < samples/1

% mkdir -p trash; (cat trash/style.html 2>/dev/null; sed 's:\(.\):<span>\1</span>:g; s/$/<br>/' < samples/1) > trash/sample.html

$ ghc -prof -fprof-auto -rtsopts solve && ./solve +RTS -p < samples/3

$ ghc solve.hs -rtsopts -with-rtsopts='-M128m' && ./solve < samples/3
