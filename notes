ws ws://maze.server.host/game-pipes/

┓┻┣┣┫┛╹┏
╹┃╺┃╺╸╹┻
╻┛╹━╺╻┓┃
┗━━┻┏┳┣┓
┗━┃┣┃┻╻╺
━╻┛┳┃┳╺━
┃┳┫┳╺┣┛━
┗┓╸╻╺┛┛┏

━┃┏┓┗┛┣┫┳┻╋╸╹╺╻

1,    ╹
12,   ┗
123,  ┣
1234, ╋
124,  ┻
13,   ┃
134,  ┫
14,   ┛
2,    ╺
23,   ┏
234,  ┳
24,   ━
3,    ╻
34,   ┓
4,    ╸

I: ━, ┃
L: ┏, ┛, ┓, ┗
T: ┣, ┫, ┳, ┻
X: ╋
i: ╸, ╹, ╺, ╻

1: 8x8
5: 1200x130
6: 3000x1000

--

1. mums nevajag immutable, mums vajag mutable
1.1. mutable ja tikai viens

2. mums vajag a*?
2.1. store order in btree (has min/max keys?)

3. jāsāk ar malām. vai mums vajag checkerboardā likt klucīšus lai būtu labāki minējumi immediately?

4. iespējams, ka var optimizēt sākot rēķināt no singletoniem

5. varbūt, ka lētāk ir storēt directionus vai nu vektorā vai optimizēt ar lookup table
5.2. special character for wall/uncertain
5.3. optimizēt best ar hashmap O(1), kas ir valīds visiem boardiem

6. simetrijām var nečekot rotācijas (krustam/taisnēm)

7. strongly connected
7.1. ja šis ir solved un ir T vai I, tad var solvēt dažus no apkārtējiem zariem (ja nekonnektējas) – they're forced
7.2. ja šis apmeklēts, tad solved set
7.3. ja rotation is pixValid, tad continue list = (new branches + forced + continue) filter solved. start with first from continue
7.4. ja continue ir empty & size == boardsize, tad valid

8. rotations = filter pixvalid rotations
8.1. if rotations == 1, tad var lietot mutable implement uz boarda

--

2020-12-26-18:55:23
✔ 1. Sides first in backtracking
✔ 2. Solve edge first, sort by solvability
✔ 3. Force unpointed
✔. Check stranded islands (jo dziļāk, jo dziļāk vērts rekursēt)
✔. Store origin in cursors
✔. Render cursor with list of sets per color
7. Subsolve regions around edges that don't touch each other, then combine partially solved solutions
7.1. index partial sets by origin cursor

--

2020-12-27-13:34:54
✔ 1. solve sides faster than just unambiguous (nextFast) by pop(1) initial only
2. lifecycle is decreasing, returns solve_ returns Either PartialSolution Maze
3. with PartialSolutions, you can share unaffected regions
4. maybe optimize board by using canoical rotation
5. 4*4 precomputed partial solutions

--

2020-12-27-20:02:40
1. lifecycle decreasing resulting in partial solutions list and solve'
2. calculate unambiguous pieces
3. share solutions
4. maze'
5. solve indirect ambiguous for failure
6. solve'' :: -> Either [PartialSolution] Maze
7. sortContinues with 2nd priority as in diagonals to current
8. unambiguous in Cursor
9. continue as list, initial as unambiguous Cursors (rotations = 1 then next unambiguous if unambiguous)
10. a single hashtable

2020-12-30-13:24:35
1. maybe join solutions by (intersection solved empty), copy solveds, uniq continues
2. hashtable record with functions (= 10. from previous)
3. (not a worthwhile idea) join all continue with choice = 1 solutions
4. nextSolution filter choice = 0

2021-01-10-15:25:31
1. websocket client
2. make maze Vector Vector for more memory sharing
3. optimize by profiler

2021-01-13-13:28:53
1. Make Maze a record with
1.1. board :: Data.Vector.Unboxed.Mutable.MVector Cursor (Char, PartId, solved :: Bool)
1.2. continue :: [Continue]
1.3. solves :: Data.Vector.Unboxed.Mutable.MVector as stack + stack size Int
1.4. bang patterns for all records
2. with mutable maze, when backtracking, set solved = false the cursor from solved stack
3. chocie! in solve' you can explore the rotations with connecting to most solveds first
4. choice! there's the option to abandon solutions with unfavorable characteristics (unconnected component with long, narrow path)
4.1. narrow: compute another score for narrowness, return the maze

2021-01-17-23:33:23
1. mutable vector rewrite
2. audit mazeReads to spot any redundancy
3. cursorDeltasWithWalls
4. strict data everywhere
5. suspendable progress with data about the remaning search space [[Rotation]] or, essentially, [[Continue]]
6. backtracking with fairness and thus parallel
(7. explore if it's worth to keep a pure, unsafe frozen version of MVector)

2021-01-18-23:37:26
1. mvector refactor last bug: unwind should also unwind partEquiv modifications and maybe partEquiv should be Maybe
2. export mutations to top, so it's easier write the unwind procedure

--

9f9a4fe
runhaskell solve.hs 2>&1 < samples/2  15.52s user 2.79s system 59% cpu 30.526 total

9f9a4fe + usePixValidPrecomputed
runhaskell solve.hs 2>&1 < samples/2  74.92s user 3.69s system 84% cpu 1:33.56 total
(actual solving timed with phone: 30s... same as with usePixValidPrecomputed = False)

./solve < samples/2-2  4.36s user 0.02s system 99% cpu 4.380 total

./solve < ./samples/3  1.73s user 0.03s system 99% cpu 1.772 total

--

% mkdir -p trash; (cat trash/style.html 2>/dev/null; sed 's:\(.\):<span>\1</span>:g; s/$/<br>/' < samples/1) > trash/sample.html

--

# profiler
  % ghc -prof -fprof-auto -rtsopts solve -with-rtsopts='-p' && ./solve < samples/2

# print trace of crash
  % ghc solve.hs -prof -with-rtsopts='-xc' && ./solve < samples/2

# restrict heap
  $ ghc solve.hs -rtsopts -with-rtsopts='-M1024m' && ./solve < samples/3

# run 8 cores
  % ghc solve.hs -threaded -with-rtsopts='-N8' && time ./solve < ./samples/3

--

on 7a05ccc at 2021-01-10-15:26:16
  pixValidRotations.checkDirection      Main        solve.hs:(229,5)-(237,73)         15.3    4.0
  lookupConverge.lookupDef              Main        solve.hs:94:5-53                  14.2    5.4
  sortContinues                         Main        solve.hs:(250,1)-(255,41)          8.1   19.1
  matrixBounded                         Main        solve.hs:65:1-71                   5.6    6.7
  pixValid.satisfied                    Main        solve.hs:213:5-77                  4.4    3.3
  lookupConverge.lookup                 Main        solve.hs:93:5-96                   4.2    8.4
  solveRotation.next                    Main        solve.hs:(303,5)-(308,44)          3.8    1.2
  sortContinues.depth                   Main        solve.hs:255:5-41                  3.7    6.2
  rotateDir                             Main        solve.hs:178:1-31                  3.3    3.1
  toPix                                 Main        solve.hs:148:1-19                  3.2    0.0
  converge                              Main        solve.hs:87:1-31                   2.7    1.6
  mxSetElem                             Main        solve.hs:84:1-52                   2.4   15.0
  solveRotation.partEquiv'              Main        solve.hs:322:5-83                  2.0    1.3
  pixValidRotations.\                   Main        solve.hs:219:10-42                 2.0    2.7
  cursorDelta                           Main        solve.hs:(198,1)-(202,60)          1.9    1.8
  mxGetElem                             Main        solve.hs:79:1-46                   1.8    1.2
  solveRotation.dropBad                 Main        solve.hs:299:5-57                  1.5    0.2
  pixValidRotations.checkDirection.char Main        solve.hs:237:11-73                 1.4    1.0
  rotate                                Main        solve.hs:184:1-28                  1.4    2.6
  cursorDeltasSafe                      Main        solve.hs:206:1-89                  1.3    1.3
  solveRotation                         Main        solve.hs:(285,1)-(322,83)          1.2    1.4
  solve'.solveRotation'                 Main        solve.hs:(330,5)-(336,36)          1.1    0.8
  safeGet                               Data.Matrix Data/Matrix.hs:(480,1)-(482,37)    1.0    0.0
  solve'                                Main        solve.hs:(325,1)-(336,36)          1.0    0.8
  pixValid                              Main        solve.hs:(211,1)-(215,64)          0.9    1.5
  lookupConverge                        Main        solve.hs:(91,1)-(95,28)            0.5    1.1
  pixValidRotations                     Main        solve.hs:(218,1)-(237,73)          0.3    1.0
