ws ws://maze.server.host/game-pipes/

┓┻┣┣┫┛╹┏
╹┃╺┃╺╸╹┻
╻┛╹━╺╻┓┃
┗━━┻┏┳┣┓
┗━┃┣┃┻╻╺
━╻┛┳┃┳╺━
┃┳┫┳╺┣┛━
┗┓╸╻╺┛┛┏

━┃┏┓┗┛┣┫┳┻╋╸╹╺╻

1,    ╹
12,   ┗
123,  ┣
1234, ╋
124,  ┻
13,   ┃
134,  ┫
14,   ┛
2,    ╺
23,   ┏
234,  ┳
24,   ━
3,    ╻
34,   ┓
4,    ╸

I: ━, ┃
L: ┏, ┛, ┓, ┗
T: ┣, ┫, ┳, ┻
X: ╋
i: ╸, ╹, ╺, ╻

1: 8x8
5: 1200x130
6: 3000x1000

--

1. mums nevajag immutable, mums vajag mutable
1.1. mutable ja tikai viens

2. mums vajag a*?
2.1. store order in btree (has min/max keys?)

3. jāsāk ar malām. vai mums vajag checkerboardā likt klucīšus lai būtu labāki minējumi immediately?

4. iespējams, ka var optimizēt sākot rēķināt no singletoniem

5. varbūt, ka lētāk ir storēt directionus vai nu vektorā vai optimizēt ar lookup table
5.2. special character for wall/uncertain
5.3. optimizēt best ar hashmap O(1), kas ir valīds visiem boardiem

6. simetrijām var nečekot rotācijas (krustam/taisnēm)

7. strongly connected
7.1. ja šis ir solved un ir T vai I, tad var solvēt dažus no apkārtējiem zariem (ja nekonnektējas) – they're forced
7.2. ja šis apmeklēts, tad solved set
7.3. ja rotation is pixValid, tad continue list = (new branches + forced + continue) filter solved. start with first from continue
7.4. ja continue ir empty & size == boardsize, tad valid

8. rotations = filter pixvalid rotations
8.1. if rotations == 1, tad var lietot mutable implement uz boarda

--

2020-12-26-18:55:23
✔ 1. Sides first in backtracking
✔ 2. Solve edge first, sort by solvability
✔ 3. Force unpointed
✔. Check stranded islands (jo dziļāk, jo dziļāk vērts rekursēt)
✔. Store origin in cursors
✔. Render cursor with list of sets per color
7. Subsolve regions around edges that don't touch each other, then combine partially solved solutions
7.1. index partial sets by origin cursor

--

2020-12-27-13:34:54
✔ 1. solve sides faster than just unambiguous (nextFast) by pop(1) initial only
2. lifecycle is decreasing, returns solve_ returns Either PartialSolution Maze
3. with PartialSolutions, you can share unaffected regions
4. maybe optimize board by using canoical rotation
5. 4*4 precomputed partial solutions

--

2020-12-27-20:02:40
1. lifecycle decreasing resulting in partial solutions list and solve'
2. calculate unambiguous pieces
3. share solutions
4. maze'
5. solve indirect ambiguous for failure
6. solve'' :: -> Either [PartialSolution] Maze
7. sortContinues with 2nd priority as in diagonals to current
8. unambiguous in Cursor
9. continue as list, initial as unambiguous Cursors (rotations = 1 then next unambiguous if unambiguous)
10. a single hashtable

2020-12-30-13:24:35
1. maybe join solutions by (intersection solved empty), copy solveds, uniq continues
2. hashtable record with functions (= 10. from previous)
3. (not a worthwhile idea) join all continue with choice = 1 solutions
4. nextSolution filter choice = 0

2021-01-10-15:25:31
1. websocket client
2. make maze Vector Vector for more memory sharing
3. optimize by profiler

2021-01-13-13:28:53
1. Make Maze a record with
1.1. board :: Data.Vector.Unboxed.Mutable.MVector Cursor (Char, PartId, solved :: Bool)
1.2. continue :: [Continue]
1.3. solves :: Data.Vector.Unboxed.Mutable.MVector as stack + stack size Int
1.4. bang patterns for all records
2. with mutable maze, when backtracking, set solved = false the cursor from solved stack
3. chocie! in solve' you can explore the rotations with connecting to most solveds first
4. choice! there's the option to abandon solutions with unfavorable characteristics (unconnected component with long, narrow path)
4.1. narrow: compute another score for narrowness, return the maze

2021-01-17-23:33:23
1. mutable vector rewrite
2. audit mazeReads to spot any redundancy
3. cursorDeltasWithWalls
4. strict data everywhere
5. suspendable progress with data about the remaning search space [[Rotation]] or, essentially, [[Continue]]
6. backtracking with fairness and thus parallel
(7. explore if it's worth to keep a pure, unsafe frozen version of MVector)

2021-01-18-23:37:26
1. mvector refactor last bug: unwind should also unwind partEquiv modifications and maybe partEquiv should be Maybe
2. export mutations to top, so it's easier write the unwind procedure

2021-01-26-22:51:04
1. try sorting by connectivity in pixValidRotations
2. continues as set + deleteMin to remove continue sort bottleneck
3. try out parallel solving
3.1. by storing a list of Progresses (split space) (can be expensive, because of maze copies)
3.2. store only best solve of each pixValidRotations (run on new core for limited depth)
3.3. heuristics: pick only the luckiest (depth vs iteration) OR narrowest (fewest disconnected components)
3.4. print how many choices do we usually have per-square – is it ever four? (we'd need to combine choices to utilize more cores)
4. make maze pieces from chars to ints and do direct indexing for caching, but only aftre
5. see if we can cut down on data in Continue (direct, choices are not necessary, char → int)
6. see if lookup maps are ever reevaluated due to GC

--

9f9a4fe
runhaskell solve.hs 2>&1 < samples/2  15.52s user 2.79s system 59% cpu 30.526 total

9f9a4fe + usePixValidPrecomputed
runhaskell solve.hs 2>&1 < samples/2  74.92s user 3.69s system 84% cpu 1:33.56 total
(actual solving timed with phone: 30s... same as with usePixValidPrecomputed = False)

./solve < samples/2-2  4.36s user 0.02s system 99% cpu 4.380 total

./solve < ./samples/3  1.73s user 0.03s system 99% cpu 1.772 total

--

% mkdir -p trash; (cat trash/style.html 2>/dev/null; sed 's:\(.\):<span>\1</span>:g; s/$/<br>/' < samples/1) > trash/sample.html

--

# profiler
  % ghc -prof -fprof-auto -rtsopts solve -with-rtsopts='-p' -fexternal-interpreter && ./solve < samples/1

# print trace of crash
  % ghc solve.hs -prof -with-rtsopts='-xc' && ./solve < samples/2

# restrict heap
  $ ghc solve.hs -rtsopts -with-rtsopts='-M1024m' && ./solve < samples/3

# run 8 cores
  % ghc solve.hs -threaded -with-rtsopts='-N8' && time ./solve < ./samples/3

# :l solve without having to resolve all type errors (amazing!)
  % ghci -fdefer-type-errors

--

on 7a05ccc at 2021-01-10-15:26:16
  pixValidRotations.checkDirection      Main        solve.hs:(229,5)-(237,73)         15.3    4.0
  lookupConverge.lookupDef              Main        solve.hs:94:5-53                  14.2    5.4
  sortContinues                         Main        solve.hs:(250,1)-(255,41)          8.1   19.1
  matrixBounded                         Main        solve.hs:65:1-71                   5.6    6.7
  pixValid.satisfied                    Main        solve.hs:213:5-77                  4.4    3.3
  lookupConverge.lookup                 Main        solve.hs:93:5-96                   4.2    8.4
  solveRotation.next                    Main        solve.hs:(303,5)-(308,44)          3.8    1.2
  sortContinues.depth                   Main        solve.hs:255:5-41                  3.7    6.2
  rotateDir                             Main        solve.hs:178:1-31                  3.3    3.1
  toPix                                 Main        solve.hs:148:1-19                  3.2    0.0
  converge                              Main        solve.hs:87:1-31                   2.7    1.6
  mxSetElem                             Main        solve.hs:84:1-52                   2.4   15.0
  solveRotation.partEquiv'              Main        solve.hs:322:5-83                  2.0    1.3
  pixValidRotations.\                   Main        solve.hs:219:10-42                 2.0    2.7
  cursorDelta                           Main        solve.hs:(198,1)-(202,60)          1.9    1.8
  mxGetElem                             Main        solve.hs:79:1-46                   1.8    1.2
  solveRotation.dropBad                 Main        solve.hs:299:5-57                  1.5    0.2
  pixValidRotations.checkDirection.char Main        solve.hs:237:11-73                 1.4    1.0
  rotate                                Main        solve.hs:184:1-28                  1.4    2.6
  cursorDeltasSafe                      Main        solve.hs:206:1-89                  1.3    1.3
  solveRotation                         Main        solve.hs:(285,1)-(322,83)          1.2    1.4
  solve'.solveRotation'                 Main        solve.hs:(330,5)-(336,36)          1.1    0.8
  safeGet                               Data.Matrix Data/Matrix.hs:(480,1)-(482,37)    1.0    0.0
  solve'                                Main        solve.hs:(325,1)-(336,36)          1.0    0.8
  pixValid                              Main        solve.hs:(211,1)-(215,64)          0.9    1.5
  lookupConverge                        Main        solve.hs:(91,1)-(95,28)            0.5    1.1
  pixValidRotations                     Main        solve.hs:(218,1)-(237,73)          0.3    1.0

--

on ce59523 at 2021-01-25-23:51:04

solve +RTS -p -RTS
  total time  =        8.73 secs   (8727 ticks @ 1000 us, 1 processor)
  total alloc = 19,387,362,136 bytes  (excludes profiling overheads)

  COST CENTRE                       MODULE    SRC                        %time %alloc
  mazeRead                          Main      solve.hs:143:1-67           32.4   41.1
  solveContinue.continuesNextSorted Main      solve.hs:(370,5)-(372,84)   20.7   25.4
  mazeCursorSolved                  Main      solve.hs:146:1-86            8.6   11.3
  mazeModify                        Main      solve.hs:(149,1)-(152,8)     6.4    6.7
  pieceDead.dead.discontinued       Main      solve.hs:(342,9)-(345,40)    2.5    1.4
  solveContinue                     Main      solve.hs:(351,1)-(372,84)    2.1    0.8
  mazeDeltas                        Main      solve.hs:(279,1)-(282,66)    1.9    1.1
  partEquate.loop'.\                Main      solve.hs:179:27-81           1.7    0.5
  rotateDir                         Main      solve.hs:263:1-31            1.6    0.7
  pixValid.satisfied                Main      solve.hs:298:5-81            1.6    0.6
  pieceRotations.validateRotation   Main      solve.hs:313:5-75            1.5    0.6
  mazeBounded                       Main      solve.hs:128:1-70            1.5    0.7
  toPix                             Main      solve.hs:259:1-19            1.4    0.0
  solve'                            Main      solve.hs:(376,1)-(391,75)    1.1    0.4
  partEquate.find                   Main      solve.hs:178:5-95            1.1    1.2
  partEquate                        Main      solve.hs:(176,1)-(179,94)    1.1    0.4

% ghc solve && for i in {1..4}; do time ./solve < samples/4 2>&1 | grep total; done
./solve < samples/4 2>&1  4.87s user 0.03s system 99% cpu 4.900 total
grep --colour total  0.00s user 0.00s system 0% cpu 4.899 total
./solve < samples/4 2>&1  4.86s user 0.03s system 99% cpu 4.895 total
grep --colour total  0.00s user 0.00s system 0% cpu 4.895 total
./solve < samples/4 2>&1  4.86s user 0.03s system 99% cpu 4.891 total
grep --colour total  0.00s user 0.00s system 0% cpu 4.890 total
