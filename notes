ws ws://maze.server.host/game-pipes/

┓┻┣┣┫┛╹┏
╹┃╺┃╺╸╹┻
╻┛╹━╺╻┓┃
┗━━┻┏┳┣┓
┗━┃┣┃┻╻╺
━╻┛┳┃┳╺━
┃┳┫┳╺┣┛━
┗┓╸╻╺┛┛┏

["━", "┛", "┃", "┫", "┗", "┓", "┻", "╹", "┣", "╺", "┏", "╻", "╸", "┳", "╋"]

━
┃
┏
┓
┗
┛
┣
┫
┳
┻
╋
╸
╹
╺
╻

1,    ╹
12,   ┗
123,  ┣
1234, ╋
124,  ┻
13,   ┃
134,  ┫
14,   ┛
2,    ╺
23,   ┏
234,  ┳
24,   ━
3,    ╻
34,   ┓
4,    ╸

1: 8x8
5: 1200x130
6: 3000x1000

    validateDirection d =
      trace (show (d, rot, "//", filter (flipDir d ==) thisRequires, filter (flipDir d ==) thatRequires)) $
      filter (flipDir d ==) thisRequires == filter (flipDir d ==) thatRequires

            killStrandedSides :: [()]
            killStrandedSides =
              if any stranded $ cursorDeltasSafe maze cur unpointed
              then []
              else [()]
              where
                unpointed = flipPix $ mapChar rotated
                stranded = cursorDeltasSafe maze

    -- maze = Mx.mapPos (\_ -> fst . (canonicalRotations !)) maze'
    -- () signals fialure
    -- badContinues :: [Continue] -> CursorSet -> Maze -> Bool
    -- badContinues continues solveds maze =
    --   any null . (\x -> trace (show ("subsolves:", x)) x) $ do
    --     c@(h, o) <- take 20 . drop 1 $ continues
    --     -- solve'' 100 0 o h [] solveds (continues \\ [c]) maze
    --     (pure $ solve'' 100 0 o (t h) [] solveds (continues \\ [c]) maze) :: [[Either () Maze]]

        -- z <- seq (t (lifespan /= (-1), iter `mod` 5 == 0, badContinues continues solveds maze)) $
        --   if lifespan /= (-1) && iter `mod` 5 == 0 && badContinues continues solveds maze
        --   then []
        --   else [()]
        -- z <- if lifespan > 0 then trace (show ("trying", lifespan, iter, rotations)) [()] else [()]

m n = Mx.matrix 20 20 (const n)
matrixCopy (constraintMet [(4, (0,1))] . (\(y, x) -> (x - 1, y - 1))) (m 0) (m 1)

    -- solve' psolutions = (>>= solve' . map (widenSolution 2)) . (>>= combine) . sequence $ (map traceBoard psolutions) >>= solve'' (-1)
          -- traverse (foldM1 combinePsolves . (\x -> trace (show $ map (\g -> (constraints $ head g, length g)) x) (seq (traceBoard . head <$> x)) x) . groupSortOn constraints)

    badS = not . Set.null $ Set.intersection (solveds a) (solveds b)
    badC = not . Set.null $ Set.intersection (Set.fromList $ constraints a) (Set.fromList $ constraints b)
    badCopy = not . Set.null $
      Set.intersection
        (Set.fromList $ filter (constraintMet (constraints a)) (matrixIndices (maze a)))
        (Set.fromList $ filter (constraintMet (constraints b)) (matrixIndices (maze b)))

        -- group = map snd . sortOn fst . groupSort . map ((map (quadrantShrink 2) . constraints) >>= (,))

--

I: ━, ┃
L: ┏, ┛, ┓, ┗
T: ┣, ┫, ┳, ┻
X: ╋
i: ╸, ╹, ╺, ╻

1. mums nevajag immutable, mums vajag mutable
1.1. mutable ja tikai viens

2. mums vajag a*?
2.1. store order in btree (has min/max keys?)

3. jāsāk ar malām. vai mums vajag checkerboardā likt klucīšus lai būtu labāki minējumi immediately?

4. iespējams, ka var optimizēt sākot rēķināt no singletoniem

5. varbūt, ka lētāk ir storēt directionus vai nu vektorā vai optimizēt ar lookup table
5.2. special character for wall/uncertain
5.3. optimizēt best ar hashmap O(1), kas ir valīds visiem boardiem

6. simetrijām var nečekot rotācijas (krustam/taisnēm)

7. strongly connected
7.1. ja šis ir solved un ir T vai I, tad var solvēt dažus no apkārtējiem zariem (ja nekonnektējas) – they're forced
7.2. ja šis apmeklēts, tad solved set
7.3. ja rotation is pixValid, tad continue list = (new branches + forced + continue) filter solved. start with first from continue
7.4. ja continue ir empty & size == boardsize, tad valid

8. rotations = filter pixvalid rotations
8.1. if rotations == 1, tad var lietot mutable implement uz boarda

--

2020-12-26-18:55:23
✔ 1. Sides first in backtracking
✔ 2. Solve edge first, sort by solvability
✔ 3. Force unpointed
✔. Check stranded islands (jo dziļāk, jo dziļāk vērts rekursēt)
✔. Store origin in cursors
✔. Render cursor with list of sets per color
7. Subsolve regions around edges that don't touch each other, then combine partially solved solutions
7.1. index partial sets by origin cursor

--

2020-12-27-13:34:54
✔ 1. solve sides faster than just unambiguous (nextFast) by pop(1) initial only
2. lifecycle is decreasing, returns solve_ returns Either PartialSolution Maze
3. with PartialSolutions, you can share unaffected regions
4. maybe optimize board by using canoical rotation
5. 4*4 precomputed partial solutions

--

2020-12-27-20:02:40
1. lifecycle decreasing resulting in partial solutions list and solve'
2. calculate unambiguous pieces
3. share solutions
4. maze'
5. solve indirect ambiguous for failure
6. solve'' :: -> Either [PartialSolution] Maze
7. sortContinues with 2nd priority as in diagonals to current
8. unambiguous in Cursor
9. continue as list, initial as unambiguous Cursors (rotations = 1 then next unambiguous if unambiguous)
10. a single hashtable

2020-12-30-13:24:35
1. maybe join solutions by (intersection solved empty), copy solveds, uniq continues
2. hashtable record with functions (= 10. from previous)
3. (not a worthwhile idea) join all continue with choice = 1 solutions
4. nextSolution filter choice = 0

2021-01-10-15:25:31
1. websocket client
2. make maze Vector Vector for more memory sharing
3. optimize by profiler

--

9f9a4fe
runhaskell solve.hs 2>&1 < samples/2  15.52s user 2.79s system 59% cpu 30.526 total

9f9a4fe + usePixValidPrecomputed
runhaskell solve.hs 2>&1 < samples/2  74.92s user 3.69s system 84% cpu 1:33.56 total
(actual solving timed with phone: 30s... same as with usePixValidPrecomputed = False)

./solve < samples/2-2  4.36s user 0.02s system 99% cpu 4.380 total

./solve < ./samples/3  1.73s user 0.03s system 99% cpu 1.772 total

--

% samples/get 1; runhaskell solve.hs 2>&1 < samples/1

% mkdir -p trash; (cat trash/style.html 2>/dev/null; sed 's:\(.\):<span>\1</span>:g; s/$/<br>/' < samples/1) > trash/sample.html

$ ghc -prof -fprof-auto -rtsopts solve && ./solve +RTS -p < samples/3

$ ghc solve.hs -rtsopts -with-rtsopts='-M1024m' && ./solve < samples/3

% ghc solve.hs -prof -with-rtsopts='-xc' && time ./solve < samples/1

% ghc solve.hs -threaded -with-rtsopts='-N8' && time ./solve < ./samples/3

--

on 7a05ccc at 2021-01-10-15:26:16
  pixValidRotations.checkDirection      Main        solve.hs:(229,5)-(237,73)         15.3    4.0
  lookupConverge.lookupDef              Main        solve.hs:94:5-53                  14.2    5.4
  sortContinues                         Main        solve.hs:(250,1)-(255,41)          8.1   19.1
  matrixBounded                         Main        solve.hs:65:1-71                   5.6    6.7
  pixValid.satisfied                    Main        solve.hs:213:5-77                  4.4    3.3
  lookupConverge.lookup                 Main        solve.hs:93:5-96                   4.2    8.4
  solveRotation.next                    Main        solve.hs:(303,5)-(308,44)          3.8    1.2
  sortContinues.depth                   Main        solve.hs:255:5-41                  3.7    6.2
  rotateDir                             Main        solve.hs:178:1-31                  3.3    3.1
  toPix                                 Main        solve.hs:148:1-19                  3.2    0.0
  converge                              Main        solve.hs:87:1-31                   2.7    1.6
  mxSetElem                             Main        solve.hs:84:1-52                   2.4   15.0
  solveRotation.partEquiv'              Main        solve.hs:322:5-83                  2.0    1.3
  pixValidRotations.\                   Main        solve.hs:219:10-42                 2.0    2.7
  cursorDelta                           Main        solve.hs:(198,1)-(202,60)          1.9    1.8
  mxGetElem                             Main        solve.hs:79:1-46                   1.8    1.2
  solveRotation.dropBad                 Main        solve.hs:299:5-57                  1.5    0.2
  pixValidRotations.checkDirection.char Main        solve.hs:237:11-73                 1.4    1.0
  rotate                                Main        solve.hs:184:1-28                  1.4    2.6
  cursorDeltasSafe                      Main        solve.hs:206:1-89                  1.3    1.3
  solveRotation                         Main        solve.hs:(285,1)-(322,83)          1.2    1.4
  solve'.solveRotation'                 Main        solve.hs:(330,5)-(336,36)          1.1    0.8
  safeGet                               Data.Matrix Data/Matrix.hs:(480,1)-(482,37)    1.0    0.0
  solve'                                Main        solve.hs:(325,1)-(336,36)          1.0    0.8
  pixValid                              Main        solve.hs:(211,1)-(215,64)          0.9    1.5
  lookupConverge                        Main        solve.hs:(91,1)-(95,28)            0.5    1.1
  pixValidRotations                     Main        solve.hs:(218,1)-(237,73)          0.3    1.0
